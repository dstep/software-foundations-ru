(** * Предисловие *)

(* ################################################################# *)
(** * Приветствие *)

(** Это - начало серии электронных книг о различных аспектах _Основ
    программного обеспечения_ -- математического обоснования для 
    надежных программ. Эта серия включает такие темы как основные 
    понятия логики, доказательные вычисления, средство доказательства 
    теорем Coq, функциональное программирование, операционная 
    семантика, логика рассуждений о программах, статические системы 
    типов. Повествование предназначено для широкой аудитории, 
    от продвинутых студентов до аспирантов и исследователей. Особых 
    познаний в логике или языках программирования не требуется, 
    хотя некоторая степень математической интуиции будет полезной.
    
    Принципиальное новшество этой серии состоит в том, что она 
    полностью формализована и проверена при помощи компьютера: 
    каждый текст является программой для Coq. Книги стоит читать 
    параллельно (или прямо внутри) интерактивной сессии Coq. 
    Большинство упражнений предназначены для выполнения в Coq.

    Файлы каждой книги организованы в последовательность основных глав,
    предназначенных для изучения в течение одного семестра, и некоторое
    число отдельных глав покрывающих дополнительные темы. Все базовые
    главы подходят и для старшекурсников, и для выпускников.

    Эта книга, _Основы логики_, закладывает фундамент для прочих,
    предоставляя для читателя введение в функциональное
    программирование, конструктивную логику и средство доказательства 
    теорем Coq.

(* ################################################################# *)
(** * Обзор *)

(** Создание надежного программного обеспечения - очень сложная задача.
    Масштаб и сложность современных систем, число людей, вовлеченных
    в их создание, а также диапазон возлагаемых на них требований
    делают невероятно трудным написание относительно правильных
    программ, не говоря уже о правильных на 100%. В то же время, 
    степень вовлечения программной обработки информации в каждый аспект
    жизни многократно увеличивает цену ошибок и уязвимостей.

    Разработчики программного обеспечения и информатики-теоретики 
    подошли к этим проблемам, разработав множество техник для 
    увеличения надежности, от рекомендаций по управлению командами,
    разрабатывающими ПО (например, экстремальное программирование) до
    философии проектирования библиотек (паттерны проектирования, такие
    как MVC, pub-sub и т.д.) и языков программирования (объектно-
    ориентированные, аспектно-ориентированные, функциональные...)
    и математические техники для указания и рассуждения о свойствах ПО,
    а также инструменты для проверки этих свойств. _Основы
    программного обеспечения_ концентрируются именно на последнем 
    наборе техник.

    Текст построен вокруг трех основных тем:

    (1) основные инструменты _логики_ для выдвижения и доказательства
        утверждений о программах

    (2) использование _средств доказательства_ для построения строгих
        доказательств

    (3) _функциональное программирование_, используемое и как метод для
        написания программ, и как связующее звено между 
		программированием и логикой.

    Некоторые предложения для дальнейшего изучения можно найти в главе
    [Послесловие (Postscript)]. Библиографическая информация находится 
    в файле [Bib] *)

(* ================================================================= *)
(** ** Логика *)

(** Логика - это область, чьим объектом изучения являются
    _доказательства_ - неопровержимые свидетельства истинности 
    определенных утверждений. О центральной роли логики в информатике
    были написаны целые тома. 
  
    Прим. перев.: оригинал приводит цитаты о важности логики, которые
    автор перевода не считает нужным и возможным переводить, чтобы
    не исказить смысл, поэтому приводит как в оригинале:

    Manna and Waldinger called it "the calculus of
    computer science," while Halpern et al.'s paper _On the Unusual
    Effectiveness of Logic in Computer Science_ catalogs scores of
    ways in which logic offers critical tools and insights.  Indeed,
    they observe that, "As a matter of fact, logic has turned out to
    be significiantly more effective in computer science than it has
    been in mathematics.  This is quite remarkable, especially since
    much of the impetus for the development of logic during the past
    one hundred years came from mathematics."

    В особенности, основные инструменты _доказательства по индукции_
    повсеместно используются в информатике. Вы конечно же видели их 
    прежде, в курсе дискретной математики или анализа алгоритмов, но
    в этом курсе мы, вероятно, изучим их более подробно, чем вы делали 
    это прежде. *)

(* ================================================================= *)
(** ** Средства доказательства *)

(** Информатика не только заимствует идеи из логики, но также и сама
    сделала важный вклад в логику. Одним из ее достижений является 
    разработка программных средств для построения доказательств
    логических высказываний. Эти инструменты разделяются на две широких
    категории:

      - _Иснтрументы автоматического доказательства (Automated theorem 
        provers)_ предоставляют "кнопку, которую надо нажать" - вы
        задаете утверждение и они возвращают ответ - _истина_ или 
        _ложь_(или, иногда, _неизвестно: время на вычисление истекло_).
        Несмотря на то, что их возможности часто ограничены 
        определенной областью применения, они чрезвычайно развились за
        последние годы и используются в множестве ситуаций. Примерами 
        таких инструментов являются SAT-решатели, SMT-решатели,
        инструменты проверки моделей.

      - _Средства доказательства (Proof assistants)_ - гибридные
        инструменты, которые автоматизируют наиболее рутинные аспекты
        доказательства, но полагаются на помощь человека в более
        сложных ситуациях. Широко используемые средства доказательства
        включают  Isabelle, Agda, Twelf, ACL2, PVS, и Coq, а также
        многие другие.

    Этот курс базируется вокруг Coq, средства доказательства, которое
    разрабатывалось с 1983 года и в недавние годы привлекло большое
    сообщество пользователей, использующих его для исследования и
    практического применения. Coq предоставляет широкие возможности
    для интерактивной разработки проверяемых компьютером рассуждений.
    Ядром Coq является простой алгоритм проверки доказательств, который
    гарантирует, что в доказательстве используются только корректные
    шаги. Поверх этого ядра, окружение Coq предоставляет
    высокоуровневые возможности разработки доказательств, включая
    обширную библиотеку определений и теореме, мощные тактики для
    построения сложных доказательств полуавтоматически, и язык
    специального назначения для создания новых тактик для автоматизации
    доказательств в особых ситуациях.

    Coq стал важнейшим инструментом для широкого набора задача 
    информатики и математики:

    - Как _платформа для моделирования языков программирования_, он
      является стандартным инструментом среди исследователей, которые
      хотят составлять и доказывать сложные языковые концепции. Для
      примера, он был использован для проверки безопасности платформы
      JavaCard, для формальной спецификации набора инструкции
      архитектуры x86 и LLVM, а также языков программирования, таких
      как C.

    - Как _окружения для разработки сертифицированного программного
      и аппаратного обеспечения_, Coq использовался, например, для
      создания CompCert, оптимизирующего компилятора C, полностью 
      проверенного средствами Coq; верифицированного гипервизора
      CertiKos; для доказательства корректности нескольких алгоритмов 
      с числами с плавающей точкой, и как основа для CertiCrypt,
      окружения для рассуждений о безопасности криптографических 
      алгоритмов. Он также использовался для создания верифицированных
      реализаций открытого процессора RISC-V.

    - Как _функциональный язык программирования с зависимыми типами_,
      он вдохновил множество инноваций. Для примера, система Ynot 
      дополняет Coq "суждениями Хоара об отношениях" (расширение 
      _Логики Хоара_, которую мы рассмотрим в этом курсе).

    - Как _средство доказательства для логики высших порядков_, он
      использовался для подтверждения некоторых важных результатов 
      в математике. Для примера, возможность включать сложные
      вычисления в доказательства позволила получить первое полностью
      формальное доказательство теоремы о четырех красках. Прежде,
      это доказательство вызывало недоверие среди математиков, потому
      что частью его была проверка большого количества конфигураций 
      при помощи программы. В доказательстве для Coq же проверяется
      все, включая корректность вычислительной части. ПОзднее, была
      получена формализация для теоремы Фейта-Томпсона -- первый
      большой шаг на пути классификации простых конечных групп.  

    Кстати, если вас интересует происхождение названия, вот что
    официальный сайт Coq INRIA (национальная французская 
    исследовательская лаборатория, где Coq в основном разрабатывался)
    говорит об этом: "Некоторые французские информатики имеют
    традицией называть свои программы именами животных, как пример:
    Caml, Elan, Foc или Phox. На французском, 'coq' означает 'петух',
    и также его произношение совпадает с первыми буквами исчисления
    высказываний (Calculus of Constructions, CoC), на котором он 
    основан". Петух также является национальным символом Франции, и
    C-o-q - первые три буквы имени Thierry Coquand'а, одного из 
    первых разработчиков Coq. *)

(* ================================================================= *)
(** ** Функциональное программирование *)

(** Термин _функциональное программирование_ используется для 
    обозначения идиом, которые могут быть применены почти в любом
    языке программирования, и для обозначения семейства языков,
    созданных с упором на применение этих идиом, включающего Haskell,
    OCaml, Standard ML, F##, Scala, Scheme, Racket, Common Lisp, 
    Clojure, Erlang, и Coq.

    Функциональное программирование развивалось на протяжении многих
    десятилетий -- его корни берут начало от лямбда-исчисления,
    изобретенного Алонзо Черчем в 1930, задолго до первых компьютеров
    (как минимум электронных)! Но начиная с ранних девяностых оно
    удостоилось внимания среди разработчиков ПО и дизайнеров языков
    программирования, и сыграло ключевую роль в разработке приоритетных
    систем в компаниях, таких как Jane St. Capital, Microsoft, 
    Facebook, и Ericsson.

    Основополагающий принцип функционального программирования - 
    вычисления, по возможности, должны быть _чистыми_, то есть 
    единственным результатом выполнения должно быть получение 
    результата: они не должны иметь _побочных эффектов_, таких как
    ввод/вывод, присвоение значений изменяемым переменным,
    перенаправление указателей, и так далее. Например, там где
    _императивная_ процедура сортировки может принимать список чисел
    и переставить его указатели таким образом, чтобы упорядочить 
    список, чистая функция сортировки примет оригинальный список и
    вернет _новый_ список, содержащий те же числа в правильном порядке.

    Существенным преимуществом этого стиля программирования является
    то, что он упрощает понимание и рассуждения о свойствах программ.
    Если каждая операция на структуре данных производит новую 
    структуру, не трогая старую, то нет необходимости беспокоиться
    о разделении ее между разными частями программы, и о том, как 
    изменение в одном месте может нарушить инвариант, на который 
    полагается другая часть программы. Эти соображения особенно важны
    в конкурентных системах, где каждая часть изменяемого состояния,
    разделяемая несколькими потоками, является потенциальным 
    источником багов. Действительно, большая часть недавнего интереса
    индустрии к функциональному программированию вызвано его простым
    поведением в присутствии многозадачности.

    Другая причина интереса к функциональным языкам связана с первой:
    функциональные программы намного легче поддаются распараллеливанию,
    чем императивные. Если проведение вычисления не имеет побочных 
    эффектов, кроме получения результата, то не имеет значения _где_
    его проводить. Также, если структура данных никогда не
    модифицируется, ее можно свободно копировать между разными ядрами
    или машинами в сети. В самом деле, идиома "Map-Reduce", которая
    положена в основу распределенных обработчиков, таких как Hadoop,
    и используется Google для индексации всей сети -- классический 
    пример функционального программирования.

    Для целей этого курса, функциональное программирование 
    притягательно еще по одной причине: оно служит связующим звеном
    между логикой и информатикой. И впрямь, Coq можно рассматривать
    как крайне выразительный функциональный язык программирования,
    дополненный средствами для заявления и доказательства логических
    утверждений. Более того, когда мы посмотрим более внимательно, мы
    увидим, что эти две части на самом деле обрабатываются одинаково --
    то есть, _доказательства -- это программы_.  *)


(* ================================================================= *)
(** ** Дальнейшее чтение *)

(** Этот текст предполагается самодостаточным, однако читатель,
    желающий подробнее изучить определенные темы, может найти 
    рекомендации для дальнейшего чтения в главе 
    [Послесловие (Postscript)] *)

(* ################################################################# *)
(** * Практические вопросы *)

(* ================================================================= *)
(** ** Зависимости между главами *)

(** Диаграмма зависимостей между главами и предлагаемые пути изучения
    материала находятся в файле [deps.html]. *)

(* ================================================================= *)
(** ** Системные требования *)

(** Coq работает на Windows, Linux, и OS X. Вам потребуются:

       - Установленная свежая версия Coq, доступная на его домашней 
         странице. Файлы курса был протестированы с Coq 8.6.

       - IDE  для взаимодействия с Coq. На текущий момент, доступно
         два варианта:

           - Proof General -- IDE, основанная на Emacs. Ее предпочитают
             пользователи, уже знакомые с Emacs. Требуется
             дополнительная установка (ищите "Proof General").

             Отважные пользователи Coq и Emacs могут также установить
             расширения, такие как [company-coq] и [control-lock].

           - CoqIDE -- более простая отдельная IDE. Она 
             распространяется вместе с Coq, то есть будет доступна
             сразу, когда вы установите Coq. Также может быть собрана
             вручную, что потребует установки дополнительного ПО на
             некоторых платформах, например, библиотек GUI и прочего *)

(* ================================================================= *)
(** ** Упражнения *)

(** Все главы включает многочисленные упражнения. Каждое упражнение
    отмечено "звездным рейтингом", который стоит понимать так: 

       - Одна звезда: простые упражнения, которые подчеркивают главную
         идею текста, и у большинства читателей не займут больше пары
         минут. Возьмите в привычку выполнять такие упражнения, как 
         только доберетесь до них.

       - Две звезды: простые упражнения (на пять - десять минут)

       - Три звезды: упражнения, требующие некоторого размышления
         (от десяти минут до получаса)

       - Четыре и пять звезд: более сложные упражнения (от получаса
         и более).

    Также, некоторые упражнения отмечены как "продвинутые", а некоторые
    как "опциональные". Выполнение только упражнений, не отмеченных
    как опциональные или продвинутые, хорошо покрывает основной
    материал книги. Опциональные упражнения предоставляют возможность
    дополнительно попрактиковаться с ключевыми концепциями и вводят
    второстепенные темы, которые могут быть интересны некоторым
    читателям. Продвинутые упражнения для читателей, которые хотят
    дополнительного вызова и более глубокого изучения материала.

    _Пожалуйтса, не размещайте решения упражнений публично_.
    "Основы программного обеспечения" широко используются как для 
    самообразования, так и в университетских курсах. Легкий доступ
    к решениям делает эту книгу намного менее пригодной для курсов,
    которые обычно имеют оцениваемую домашнюю работу. Мы особенно
    просим читателей не размещать решения там, где они могут быть
    найдены поисковыми системами. *)

(* ================================================================= *)
(** ** Получение файлов Coq *)

(** Полные исходные коды в tar "релиза" этой книги (в виде коллекции
    исходных файлов Coq и HTML файлов) доступны на сайте
    http://www.cis.upenn.edu/~bcpierce/sf.

    (Если вы используете эту книгу как часть курса, ваш преподаватель
    может иметь доступ к измененным версиям этих файлов, которые вам
    следует использовать вместо релизной версии.) *)

(* ================================================================= *)
(** ** Видео лекции *)

(** Лекции интенсивного летнего курса по _Основам логики_ (часть 
    DeepSpec summer school 2017) доступны по ссылке 
    https://deepspec.org/event/dsss17/coq_intensive.html .
    Качество видео не очень хорошее в начале, но улучшается 
    в дальнейших лекциях. *)

(* ################################################################# *)
(** * Заметки для преподавателей *)

(** Если вы планируете использовать материалы книги для своего курса,
    вы, без сомнения, обнаружите вещи, которые хотели бы изменить,
    улучшить, или добавить. Ваш вклад приветствуется!

    Чтобы упростить правовую сторону вопроса и иметь единственного
    ответственного в случае, если потребуется необходимость изменить
    условия лицензии, мы просим всех разработчиков (то есть всех
    с доступом к репозиторию) передать права на их работу 
    соответствующему автору:

      - I hereby assign copyright in my past and future contributions
        to the Software Foundations project to the Author of Record of
        each volume or component, to be licensed under the same terms
        as the rest of Software Foundations.  I understand that, at
        present, the Authors of Record are as follows: For Volumes 1
        and 2, known until 2016 as "Software Foundations" and from
        2016 as (respectively) "Logical Foundations" and "Programming
        Foundations," the Author of Record is Benjamin Pierce.  For
        Volume 3, "Verified Functional Algorithms", the Author of
        Record is Andrew W. Appel. For components outside of
        designated Volumes (e.g., typesetting and grading tools and
        other software infrastructure), the Author of Record is
        Benjamin Pierce.

    Чтобы начать, пожалуйста, пришлите письмо Бенжамину Пирсу, 
    в котором расскажите о себе и ваших планах по использованию 
    материала, и прикрепите
        (1) текст выше, удостоверяющий передачу вами прав
        (2) результат команды "htpasswd -s -n NAME", где NAME -- ваше
    предпочитаемое имя пользователя.

    Мы дадим вам доступ к subversion репозиторию и списку рассылки
    разработчиков. В репозитории вы найдете файл [INSTRUCTORS] с
    дальнейшими инструкциями. *)

(* ################################################################# *)
(** * Переводы *)

(** Благодаря стараниям команды добровольцев-переводчиков, 
    _Основы программного обеспечения_ доступны на японском по ссылке
    http://proofcafe.org/sf. Готовится перевод на китайский. *)

(* ################################################################# *)
(** * Благодарности *)

(** Разработка _Основ программного обеспечения_ проводилась при 
    поддержке Национального научного фонда, грант NSF Expeditions 
    1521523, _The Science of Deep Specification_. *)

(** $Date: 2017-08-24 17:13:02 -0400 (Thu, 24 Aug 2017) $ *)
