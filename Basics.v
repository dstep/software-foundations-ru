(** * Основы: функциональное программирование в Coq *)

(* НАПОМИНАНИЕ:

          #####################################################
          ###  ПОЖАЛУЙСТА НЕ ПУБЛИКУЙТЕ РЕШЕНИЯ УПРАЖНЕНИЙ  ###
          #####################################################

   (Смотрите [Предисловие] для ответа на вопрос "почему".)
*)

(* ################################################################# *)
(** * Введение *)

(** Функциональный стиль программирования основан на простой, 
    повседневной математической интуиции: если метод или процедура
    не имеют побочных эффектов, то все (кроме эффективности), о чем
    нам нужно заботиться -- какой результат сопоставляется каким
    входным данным. Таким образом, мы можем считать это конкретным
    способом вычисления математической функции. Это первое значения
    слов "функциональное программирование". Прямая связь между
    программами и простыми математическими объектами дает возможность
    проводить и формальные доказательства корректности, и неформальные
    рассуждения о поведении программ.

    Второе значение "функционального" программирования в том, что оно
    представляет функции (или методы) как _объекты первого рода_, то
    есть значения, которые можно передавать в качестве аргументов 
    другим функциям, помещать в структуры данных, и т.д. Понимание
    того, что с функциями можно обращаться как с данными, дало начало
    множеству полезных и мощных программных идиом.

    К другим частым особенностям функциональных языков программирования
    относятся _алгебраические типы данных_ и _сопоставление с 
    образцом_, что упрощает создание и работу со сложными структурами
    данных, а также мощная _полиморфная система типов_, поддерживающая
    абстракции и переиспользование кода. Coq предоставляет все эти
    возможности.

    Первая половина этой главы вводит самые важные элементы 
    функционального языка программирования _Gallina_, используемого
    Coq. Вторая часть представляет некоторые базовые _тактики_,
    используемые для доказательства свойтсв программ в Coq. *)

(* ################################################################# *)
(** * Данные и функции *)
(* ================================================================= *)
(** ** Типы-перечисления *)

(** Примечательной чертой Coq является то, что набор встроенных 
    особенностей _крайне_ мал. Например, вместо того, что предоставить
    обычный набор примитивных типов данных, как то логический тип, 
    целые числа, строки, Coq предлагает мощный механизм для задания
    новых типов данных, с помощью которого можно воссоздать все эти
    примитивы.

    Разумеется, Coq распространяется вместе с обширной стандартной
    библиотекой, предоставляющей определения логического типа, чисел,
    и многих других часто используемых структур данных вроде списков
    и хэш таблиц. Но в этих определениях нет ничего магического. Чтобы
    продемонстрировать это, мы явно воссоздадим все эти определения
    в данном курсе, вместо того, чтобы использовать заданные в 
    стандартной библиотеке. *)

(* ================================================================= *)
(** ** Дни недели *)

(** Чтобы увидеть как работает этот механизм, давайте начнем с простого
    примера. Следующее объявление говорит Coq, что мы задаем новый
    набор значений -- _тип__. *)

Inductive day : Type := (* день *)
  | monday : day (* понедельник *)
  | tuesday : day (* вторник *)
  | wednesday : day (* среда *)
  | thursday : day (* четверг *)
  | friday : day (* пятница *)
  | saturday : day (* суббота *)
  | sunday : day. (* воскресенье *)

(** Этот тип называется [day], и его челнами являются [monday],
    [tuesday], и т.д. Вторая и последующие строки определения можно
    прочитать как "[monday (понедельник)] это [day (день)], 
    [tuesday (вторник)] это [day (день)] и т.д."

    Определив [день], мы можем записать функцию, которая им оперирует.
*)

Definition next_weekday (d:day) : day := (* следующий будний день *)
  match d with
  | monday    => tuesday
  | tuesday   => wednesday
  | wednesday => thursday
  | thursday  => friday
  | friday    => monday
  | saturday  => monday
  | sunday    => monday
  end.

(** Стоит отметить, что типы аргумента и возвращаемого значения функции
    указаны явно. Как и многие функциональные языки, Coq часто может
    выяснить эти типы самостоятельно, когда они не указаны явно -- 
    это называется _выводом типов_ -- но мы в основном будем указывать
    их, чтобы упростить чтение. *)

(** Определив функцию, мы можем проверить ее работу на примерах. В Coq
    есть три способа это сделать. Во-первых, мы можем использовать
    команду [Compute] что вычислить составное выражение, включающее
    [next_weekday]. *)

Compute (next_weekday friday).
(* ==> monday : day *)

Compute (next_weekday (next_weekday saturday)).
(* ==> tuesday : day *)

(** (Мы демонстрируем ответы Coq в комментариях, однако, если компьютер
    у вас под рукой, это отличный момент чтобы запустить интерпретатор
    Coq в вашей любимой IDE -- CoqIde или Proof General -- и 
    попробовать ввести команды самостоятельно. Загрузите этот файл,
    [Basics.v] из исходных файлов Coq книги, найдите пример выше, 
    выполните его и посмотрите на результат.)

    Во-вторых, мы можем отметить, какой результат вычисления мы
    _ожидаем_ от Coq: *)

Example test_next_weekday:
  (next_weekday (next_weekday saturday)) = tuesday.

(** Это определение делает две вещи: утверждает, что второй следующий 
    будний день после [субботы (saturday)] -- это [вторник (tuesday)],
    и дает этому утверждению имя, на которое можно ссылаться в 
    дальнейщем. Сделав утверждение, мы можем попросить Coq проверить
    его, например, так: *)

Proof. simpl. reflexivity.  Qed.

(** Подробности сейчас не важны (мы вернемся к этому через некоторое
    время), но по сути это можно прочитать как "Утверждение, которое
    мы сделали, может быть доказано наблюдением того факта, что
    обе части равенства вычисляются в одно и то же значение, после
    упрощения".

    В-третьих, мы можем попросить Coq _извлечь_ из нашего 
    [Определения (Definition)] программу на более традиционном языке
    (OCaml, Scheme или Haskell) с оптимизирующим компилятором. Эта
    возможность выглядит особенно интересной, так как она позволяет
    перейти от доказанно корректных алгоритмов, написанных на языке
    Gallina, к эффективному машинному коду. (Конечно, в этом случае
    мы должны доверять корректной реализации компилятора OCaml/
    Haskell/Scheme, и алгоритму извлечения в Coq, однако это все равно
    большой шаг по сравнению с тем, как  сегодня разрабатывается 
    большая часть ПО). Действительно, извлечение - одно из основных
    предназначений Coq, для которых он разрабатывался. Мы вернемся 
    к этой теме в следующих главах. *)

(* ================================================================= *)
(** ** Руководство по подготовке домашних заданий *)

(** Если вы используете Основы программного обеспечения в рамках курса,
    ваш преподаватель, возможно, применяет автоматические средства 
    выставления оценок за домашнюю работу. Чтобы эти скрипты работали
    корректно (и вы получили полные баллы за выполненную работу!),
    пожалуйста, внимательно следуйте следующим правилам:
      - Скрипт оценки извлекает отмеченные области файлов .v, которые
        вы отправляете на проверку. То есть, важно не менять 
        "разметку" упражнений: заголовок упражнения, название
        упражнения, "пустой квадрат из скобок" в конце и т.д. 
        Пожалуйста, оставьте эту разметку точно в том виде, в котором 
        вы ее обнаружите.
      - Не удаляйте упражнения. Если вы пропустите упражнение 
        (например, потому что оно отмечено как опциональное, или 
        потому, что вы не можете решить его), можно оставить частичное
        доказательство в файле .v, но в таком случае удостоверьтесь,
        что оно завершается командой [Admitted] (а не, например,
        [Abort]).
      - Вы можете использовать дополнительные определения 
        (вспомогательные функций, леммы, и т.д.) в своих решениях.
        Их можно разместить между заголовком упражнения и теоремой,
        которую вы должны доказать. *)

(* ================================================================= *)
(** ** Логический тип *)

(** Похожим образом мы можем объявить также стандартный логический
    тип [bool], с двумя челнами: [true](истина) и [false](ложь). *)

Inductive bool : Type :=
  | true : bool
  | false : bool.

(** Хотя мы и задаем свой собственный логический тип с целью
    построить все определения с нуля, Coq, разумеется, предоставляет
    стандартную реализацию логического типа, а также множество полезных
    функций и теорем. (Вы можете найти их в [Coq.Init.Datatypes] в
    документации по библиотеке Coq). Там, где это возможно, мы будем
    давать нашим определениям и теоремам те же имена, что они имеют
    в стандартной библиотеке. 

    Функции над логичекским типом можно задавать тем же образом, что
    мы делали это выше для дней недели: *)

Definition negb (b:bool) : bool :=
  match b with
  | true => false
  | false => true
  end.

Definition andb (b1:bool) (b2:bool) : bool :=
  match b1 with
  | true => b2
  | false => false
  end.

Definition orb (b1:bool) (b2:bool) : bool :=
  match b1 with
  | true => true
  | false => b2
  end.

(** Два последних примера демонстрируют синтаксис Coq для задания
    функций с несколькими аргументами. Соответствующий ему синтаксис
    применения функций с несколькими аргументами демонстрируется
    следующими "модульными тестами", которые предоставляют полную
    спецификацию -- таблицу истинности -- для функции [orb]: *)

Example test_orb1:  (orb true  false) = true.
Proof. simpl. reflexivity.  Qed.
Example test_orb2:  (orb false false) = false.
Proof. simpl. reflexivity.  Qed.
Example test_orb3:  (orb false true)  = true.
Proof. simpl. reflexivity.  Qed.
Example test_orb4:  (orb true  true)  = true.
Proof. simpl. reflexivity.  Qed.

(** Мы можем ввести знакомый синтаксис для операций, которые только
    что определили. Комманда [Notation] задает новую нотацию для
    записи существующего определения. *)

Notation "x && y" := (andb x y).
Notation "x || y" := (orb x y).

Example test_orb5:  false || false || true = true.
Proof. simpl. reflexivity. Qed.

(** _Заметка про нотации_: в файлах Coq мы используем квадратные 
    скобки, чтобы отделять фрагменты кода в комментариях. Такое же
    соглашение используется инструментом создания документации 
    [coqdoc]. В html версии, эти фрагменты отображаются 
    [другим шрифтом].
    
    Команду [Admitted] можно использовать, чтобы оставить 
    доказательство незавершенным. Мы будем пользоваться ей 
    в упражнениях, чтобы отметить части, которые вы должны заполнить --
    то есть, вашей задачей будет заменить [Admitted] на настоящее
    доказательство. *)

(** **** Упражнение: 1 звезда (nandb)  *)
(** Удалите команду "[Admitted.]" и заполните определение следующей
    функции. Затем проверьте, что все утверждения ([Example]) ниже
    проходят проверку. Для этого удалите "[Admitted.]" в каждом и
    заполните доказательство, используя тесты для [orb] выше. 
    Функция должна возвращать [true] если одно или оба входных значения
    равны [false]. *)

Definition nandb (b1:bool) (b2:bool) : bool
  (* ЗАМЕНИТЕ ЭТУ СТРОКУ НА ":= _ваше_определение_ ." *). Admitted.

Example test_nandb1:               (nandb true false) = true.
(* ЗАПОЛНИТЕ *) Admitted.
Example test_nandb2:               (nandb false false) = true.
(* ЗАПОЛНИТЕ *) Admitted.
Example test_nandb3:               (nandb false true) = true.
(* ЗАПОЛНИТЕ *) Admitted.
Example test_nandb4:               (nandb true true) = false.
(* ЗАПОЛНИТЕ *) Admitted.
(** [] *)

(** **** Упражнение: 1 звезда (andb3)  *)
(** Сделайте то же самое для функции [andb3]. Эта функция должна
    возвращать [true] когда все ее аргументы равны [true], и [false]
    в противном случае. *)

Definition andb3 (b1:bool) (b2:bool) (b3:bool) : bool
  (* ЗАМЕНИТЕ ЭТУ СТРОКУ НА ":= _ваше_определение_ ." *). Admitted.

Example test_andb31:                 (andb3 true true true) = true.
(* ЗАПОЛНИТЕ *) Admitted.
Example test_andb32:                 (andb3 false true true) = false.
(* ЗАПОЛНИТЕ *) Admitted.
Example test_andb33:                 (andb3 true false true) = false.
(* ЗАПОЛНИТЕ *) Admitted.
Example test_andb34:                 (andb3 true true false) = false.
(* ЗАПОЛНИТЕ *) Admitted.
(** [] *)

(* ================================================================= *)
(** ** Функциональные типы *)

(** Каждое выражение в Coq имеет тип, описывающий, что оно вычисляет.
    Команда [Check] просит Coq напечатать тип выражения. *)

Check true.
(* ===> true : bool *)
Check (negb true).
(* ===> negb true : bool *)

(** Функции вроде [negb] сами по себе тоже являются данными, такими же
    как [true] и [false]. Их типы называют _функциональными типами_
    и записывают с помощью стрелок. *)

Check negb.
(* ===> negb : bool -> bool *)

(** Тип выражения [negb], записываемый как [bool -> bool], можно 
    прочитать как "Получая на вход значение типа [bool], эта функция
    возвращет значение типа [bool]". Похожим образом, тип значения
    [andb], записываемый как [bool -> bool -> bool], можно прочитать
    так: "Получая на вход два значения типа [bool], эта функция 
    возвращает значение типа [bool]". *)

(* ================================================================= *)
(** ** Составные типы *)

(** Все типы, с которыми мы имели дело, относятся к "типам-перечислениям":
    их определения явно перечисляют конечный набор элементов, каждый
    из которых является просто конструктором. Вот определение более
    интересного типа, в котором один из конструкторов принимает
    аргумент: *)

Inductive rgb : Type := 
  | red : rgb (* красный *)
  | green : rgb (* зеленый *)
  | blue : rgb. (* синий *)

Inductive color : Type := (* цвет *)
  | black : color (* черный *)
  | white : color (* белый *)
  | primary : rgb -> color. (* основной *)

(** Давайте посмотрим внимательнее.
    
    Каждый индуктивно заданный тип ([day], [bool], [rgb], [color], 
    и т.д.) содержит множество _выражений-конструкторов_, построенных
    из _конструкторов_, таких как [red], [primary], [true], [false],
    [monday], и т.д. Определения для [rgb] и [color] устанавливают,
    как строятся выражения из множеств [rgb] и [color]: 

    - [red], [green], и [blue] -- конструкторы типа [rgb];
    - [black], [white], и [primary] -- конструкторы типа [color];
    - выражение [red] принадлежит множеству [rgb], также как [green] 
      и [blue];
    - выражения [black] и [white] принадлежат множеству [color];
    - если [p] -- выражение, принадлежащее множеству [rgb], то
      [primary p] (читается "конструктор [primary], примененный к
      аргументу [p]") -- выражение, принадлежащее множеству [color]
    - это единственные способы, которыми можно получить выражения,
      принадлежащие множествам [rgb] или [color]. *)

(** Мы можем определять функции для цветов, используя сопоставление
    с образцом, также как мы делали это для [day] и [bool]. *)

Definition monochrome (c : color) : bool := (* монохромный *)
  match c with
  | black => true
  | white => true
  | primary p => false
  end.

(** Так как конструктор [primary] принимает аргумент, то образец, 
    сопоставляемый с ним, должен включать переменную (как в примере
    выше) или константу соответствующего типа (ниже). *)

Definition isred (c : color) : bool := (* является красным *)
  match c with
  | black => false
  | white => false
  | primary red => true
  | primary _ => false
  end.

(** Образец [primary _] в данном случае -- это сокращение, обозначающее
    "конструктор [primary], примененный к любому конструктору [rgb]
    кроме [red]". (Символ подстановки [_] имеет тот же эффект, что и
    фиктивная переменная [p] в определении [monochrome].) *)

(* ================================================================= *)
(** ** Модули *)

(** Для помощи в организации больших проектов Coq предоставляет
    _систему модулей_. В этом курсе большинство ее возможностей нам
    не потребуется, но одна будет полезной: если окружить набор
    определений командами [Module X] и [End X], то в оставшейся части
    файла эти определения будут доступны по именам вроде [X.foo],   
    а не просто [foo]. Мы воспользуемся этим, чтобы ввести определение
    натуральных чисел в отдельном модуле. Таким образом оно не будет
    мешать определению из стандартной библиотеки (которое мы хотим
    использовать в дальнейшем из-за удобного способа записи). *)

Module NatPlayground.

(* ================================================================= *)
(** ** Числа *)

(** Более интересный способ задать тип -- позволить его конструкторам
    принимать в качестве аргумента свой же собственный тип -- то есть,
    разрешить _индуктивные_ правила описания элементов.

    Например, мы можем задать натуральные числа таким образом: *)

Inductive nat : Type := (* натуральное число *)
  | O : nat         (* O как "0" *)
  | S : nat -> nat. (* S от Successor, Следующий *)

(** Это определение следует читать так:
      - [O] -- это натуральное число (отметьте, что это латинская 
        буква "[O]", а не цифра "[0]").
      - [S] можно поместить перед натуральным числом, чтобы получить
        новое натуральное число. То есть, если [n] -- натуральное
        число, то [S n] -- тоже натуральное число. *)

(** Давайте снова рассмотрим этот пример внимательнее. Определение 
    [nat] говорит, что выражения в множестве [nat] могут быть построены
    следующим образом:

    - [O] и [S] являются конструкторами
    - выражение [O] принадлежит множеству [nat]
    - если [n] -- выражение, принадлежащее множеству [nat], то [S n] --
      тоже выражение, принадлежащее множеству [nat]
    - выражения из множества [nat] можно построить только этими двумя
      способами. *)

(** Те же самые правила применимы и к другим нашим определениям --
    [day], [bool], [color]...

    Условия, записанные выше -- и есть точный смысл индуктивного 
    [Inductive] определения. Они означают, что выражения [O], [S O],
    [S (S O)], [S (S (S O))] и так далее -- принадлежат множеству 
    [nat], в то время как другие выражения, составленные из 
    конструкторов данных, например [true], [andb true false], 
    [S (S false)], или [O (O (O S))] -- не принадлежат.

    Важным моментом является то, что мы только задали _представление_
    чисел: способ их записи. Имена [O] и [S] выбраны нами для
    конструкторов произвольным образом, и на текущий момент не имеют
    специального значения -- это просто два разных символа, которые
    мы используем для записи чисел (вместе с правилом, что натуральное
    число записывается как последовательность символов S, за которыми
    следует символ [O]). Если бы мы захотели, мы бы могли записать
    то же самое определение таким образом: *)

Inductive nat' : Type :=
  | stop : nat'
  | tick : nat' -> nat'.

(**  _Интерпретация_ этих символов зависит от того, как мы используем
    их в вычислениях. *)

(** Мы можем сделать это, записав функцию, которая использует сравнение
    с образцом нашего представления натуральных чисел, как мы делали
    это с логическим типом и днями недели. Например, вот функция
    для вычисления предыдущего натурального числа: *)

Definition pred (n : nat) : nat :=
  match n with
    | O => O
    | S n' => n'
  end.

(** Вторую ветвь можно прочитать так: "если [n] имеет вид [S n']
    для некоторого [n'], то вернуть [n']". *)

End NatPlayground.

(** Поскольку натуральные числа -- очень распространенный тип данных,
    Coq предоставляет немного встроенной магии для их ввода и вывода.
    Обыкновенные арабские цифры можно использовать как альтернативу
    "унарной" нотации с конструкторами [S] и [O]. Coq выводит числа
    в арабской форме записи по умолчанию: *)

Check (S (S (S (S O)))).
  (* ===> 4 : nat *)

Definition minustwo (n : nat) : nat := (* отнять два *)
  match n with
    | O => O
    | S O => O
    | S (S n') => n'
  end.

Compute (minustwo 4).
  (* ===> 2 : nat *)

(** Конструктор [S] имеет тип [nat -> nat], точно такой же, как функция
    [pred] и [minustwo]: *)

Check S.
Check pred.
Check minustwo.

(** Все их можно применять к числу, чтобы получить другое число. Тем
    не менее, первое выражение фундаментально отличается от остальных:
    функции вроде [pred] и [minustwo] имеют связанные с ними _правила
    вычисления_ -- то есть, определение [pred] говорит, что [pred 2]
    может быть упрощено до числа [1] -- а вот определение [S] не 
    имеет такого поведения. И все же, выражение [S] является функцией 
    в том смысле, что его можно применять к аргументу, однако оно
    не _делает_ ничего с этим аргументом! Это просто способ записи
    числа. (Подумайте, как устроены арабские числа: число [1] не имеет
    связанного с ним вычисления, это просто данные. Когда мы записываем
    число сто одиннадцать как [111], мы используем [1] трижды, чтобы
    записать конкретное представление числа.) 

    Для большинства функций над числами простого сравнения с образцом
    не достаточно: нам также требуется рекурсия. Например, чтобы
    проверить, является ли число [n] четным, нам может потребоваться
    рекурсивно проверить, является ли [n-2] четным. Для записи таких
    функций используется ключевое слово [Fixpoint]. *)

Fixpoint evenb (n:nat) : bool :=
  match n with
  | O        => true
  | S O      => false
  | S (S n') => evenb n'
  end.

(** Мы могли бы воспользоваться командой [Fixpoint], чтобы аналогично
    задать функцию [oddb] для определения, является ли число нечетным,
    но вместо этого мы воспользуемся более простым определением: *)

Definition oddb (n:nat) : bool   :=   negb (evenb n).

Example test_oddb1:    oddb 1 = true.
Proof. simpl. reflexivity.  Qed.
Example test_oddb2:    oddb 4 = false.
Proof. simpl. reflexivity.  Qed.

(** (Если вы пройдете через эти доказательства по шагам в Coq, вы 
    заметите, что [simpl] не оказывает никакого эффекта на цель --
    вся работа выполняется командой [reflexivity]. Мы рассмотрим почему
    так происходит позже.)

    Естественно, мы можем определять функции нескольких аргументов
    с помощью рекурсии. *)

Module NatPlayground2.

Fixpoint plus (n : nat) (m : nat) : nat := (* плюс *)
  match n with
    | O => m
    | S n' => S (plus n' m)
  end.

(** Если к трем прибавить два, ожидаемо получается пять: *)

Compute (plus 3 2).

(** Чтобы достичь такого вывода, Coq выполняет следующие упрощения: *)

(*  [plus (S (S (S O))) (S (S O))]
==> [S (plus (S (S O)) (S (S O)))]
      согласно второй ветви выражения [match]
==> [S (S (plus (S O) (S (S O))))]
      согласно второй ветви выражения [match]
==> [S (S (S (plus O (S (S O)))))]
      согласно второй ветви выражения [match]
==> [S (S (S (S (S O))))]
      согласно первой ветви выражения [match]
*)

(** По соглашению, если два или более аргументов имеют одинаковый тип,
    их можно записать вместе. В следующем определении [(n m : nat)]
    значит то же самое, как если бы мы записали [(n : nat) (m : nat)].
    *)

Fixpoint mult (n m : nat) : nat := (* умножить *)
  match n with
    | O => O
    | S n' => plus m (mult n' m)
  end.

Example test_mult1: (mult 3 3) = 9.
Proof. simpl. reflexivity.  Qed.

(** Вы можете сравнивать с образцом сразу несколько значений. Для
    этого нужно разделить их запятой: *)

Fixpoint minus (n m:nat) : nat := (* минус *)
  match (n, m) with
  | (O   , _)    => O
  | (S _ , O)    => n
  | (S n', S m') => minus n' m'
  end.

(** Повторимся, что _ используется в первой строке как 
    _образец-джокер_. Записать [_] в образце -- это то же самое, что
    записать какое-нибудь имя переменной, которое не используется
    в правой части, но таким образом мы избегаем необходимости
    изобретать имя переменной. *)

End NatPlayground2.

Fixpoint exp (base power : nat) : nat := (* степень *)
  match power with
    | O => S O
    | S p => mult base (exp base p)
  end.

(** **** Упражнение: 1 звезда (factorial)  *)
(** Вспомним математическое определение факториала:

       factorial(0)  =  1
       factorial(n)  =  n * factorial(n-1)     (if n>0)

    Переведите это определение на язык Coq. *)

Fixpoint factorial (n:nat) : nat
  (* ЗАМЕНИТЕ ЭТУ СТРОКУ НА ":= _ваше_определение_ ." *). Admitted.

Example test_factorial1:          (factorial 3) = 6.
(* ЗАПОЛНИТЕ *) Admitted.
Example test_factorial2:          (factorial 5) = (mult 10 12).
(* ЗАПОЛНИТЕ *) Admitted.
(** [] *)

(** Мы можем улучшить читаемость числовых выражений с помощью _нотаций_
    для сложения, умножения и вычитания. *)

Notation "x + y" := (plus x y)
                       (at level 50, left associativity)
                       : nat_scope.
                      (* на уровне 50, левоассоциативная,
                        : в контексте натуральных чисел *) 
Notation "x - y" := (minus x y)
                       (at level 50, left associativity)
                       : nat_scope.
Notation "x * y" := (mult x y)
                       (at level 40, left associativity)
                       : nat_scope.

Check ((0 + 1) + 1).

(** (Примечания [level (уровень)], [associativity (ассоциативность)] и
    [nat_scope (контекст натуральных чисел)] управляют тем, как Coq
    обрабатывает нотацию. Для наших целей детали не важны, но
    заинтересованные читатели могут обратиться к опциональной секции
    "Подробнее о нотациях" в конце этой главы.)

    Заметьте, что этим мы не изменяем определения, которые уже дали:
    мы простро инструктируем Coq, что он должен принимать [x + y] 
    в качестве [plus x y], и наоборот, выводить [plus x y] как [x + y].
    *)

(** Когда мы говорили, что в Coq нет почти ничего встроенного, мы не
    преувеличивали: даже сравнение чисел - операция определяемая 
    пользователем! Определим ее под именем [beq_nat], что значит
    проверка натуральных чисел ([nat]) на равенство ([eq-uality]),
    где результатом является занчение логического типа ([b-oolean]).
    Обратите внимание на вложенные выражения [match]. Вместо них мы
    также могли использовать одновременное сравнение с образцом, как
    в функции [minus]. *)

Fixpoint beq_nat (n m : nat) : bool :=
  match n with
  | O => match m with
         | O => true
         | S m' => false
         end
  | S n' => match m with
            | O => false
            | S m' => beq_nat n' m'
            end
  end.

(** Функция [leb] проверяет, что ее первый аргумент меньше либо равен
    (less than or equal) второму и возвращает значение логического
    типа. *) 

Fixpoint leb (n m : nat) : bool :=
  match n with
  | O => true
  | S n' =>
      match m with
      | O => false
      | S m' => leb n' m'
      end
  end.

Example test_leb1:             (leb 2 2) = true.
Proof. simpl. reflexivity.  Qed.
Example test_leb2:             (leb 2 4) = true.
Proof. simpl. reflexivity.  Qed.
Example test_leb3:             (leb 4 2) = false.
Proof. simpl. reflexivity.  Qed.

(** **** Упражнение: 1 star (blt_nat)  *)
(** Функция [blt_nat] проверяет два натуральных [nat-ural] числа на
    отношение "меньше чем" [l-ess t-han], и возвращает значение 
    логического типа [b-oolean]. Вместо того, чтобы писать новое
    рекурсивное определение с помощью команды Fixpoint, выразите его
    через уже заданные функции. *)

Definition blt_nat (n m : nat) : bool
  (* ЗАМЕНИТЕ ЭТУ СТРОКУ НА ":= _ваше_определение_ ." *). Admitted.

Example test_blt_nat1:             (blt_nat 2 2) = false.
(* ЗАПОЛНИТЕ *) Admitted.
Example test_blt_nat2:             (blt_nat 2 4) = true.
(* ЗАПОЛНИТЕ *) Admitted.
Example test_blt_nat3:             (blt_nat 4 2) = false.
(* ЗАПОЛНИТЕ *) Admitted.
(** [] *)

(* ################################################################# *)
(** * Доказательство упрощением *)

(** Теперь, когда мы определили несколько типов данных и функций,
    давайте примемся за доказательство свойств их поведения.
    На самом деле, мы уже начали это делать: каждый пример (Example)
    в предыдущих секциях делал конкретное заявление о поведении
    функции на каких либо конкретных входных данных. Доказательства
    этих заявлений всегда были одинаковыми: использовать [simpl],
    чтобы упростить обе части равенства, затем использовать 
    [relfexivity], чтобы проверить, что значения по обе стороны от 
    равенства идентичны.

    Такой же тип "доказательства упрощением" можно использовать и
    для более интересных свойств. Например, тот факт, что [0] является
    "нейтральным элементом" для сложения [+] слева можно доказать,
    просто заметив, что выражение [0 + n] упрощается до [n], независимо
    от того, чему равно это самое [n]. Это следует прямо из определения
    функции [plus].*)

Theorem plus_O_n : forall n : nat, 0 + n = n.
Proof.
  intros n. simpl. reflexivity.  Qed.

(** (Если вы посмотрите на исходный код в файле [.v] и на HTML версию
    теоремы, вы можете заметить, что они выглядят по-разному. В файле
    [.v] мы записываем квантор всеобщности [forall], используя 
    ключевое слово "forall". Когда же файлы [.v] преобразуются в HTML,
    этот квантор преращается в перевернутую букву А.)

    Сейчас подходящее время отметить, что команда [reflexivity] немного
    мощнее, чем мы считали. В примерах, которые мы видели, команда
    [simpl] на самом деле не нужна, потому что [reflexivity] проводит
    некоторые прощения автоматически, когда сравнивает две части
    равенства. Мы добавляли команду [simpl] для того, чтобы увидеть
    промежуточное состояние -- после упрощения, но перед тем, как мы
    завершим доказательство. Вот более короткое доказательство: *)

Theorem plus_O_n' : forall n : nat, 0 + n = n.
Proof.
  intros n. reflexivity. Qed.

(** Более того, будет полезным знать, что [reflexivity] выполняет
    _больше_ упрощений, чем [simpl] -- например, эта команда пытается
    "разворачивать" определния, заменяя их имена правыми частями
    определений. Причина для такого различия в том, что если команда
    [reflexivity] успешна, то цель достигнута и нам не нужно видеть
    то выражение, которое получилось после всех упрощений и 
    подстановок. И напротив, команда [simpl] используется в ситуациях, 
    когда нам потребуется прочесть и понять новую цель, которую она 
    создает. Таким образом, мы не хотим, чтобы [simpl] разворачивала
    все определения подряд и превращала цель в нечитаемое выражение.

    Форма и доказательство теоремы этой теоремы почти точно такие же, 
    как и в более простых примерах, которые мы видели раньше. Однако,
    есть несколько отличий.

    Во-первых, вместо ключевого слова [Example](пример) мы используем 
    [Theorem](теорема). Это -- вопрос стиля. Ключевые слова [Example]
    и [Theorem] (и некоторые другие, например, [Lemma](лемма), [Fact] 
    (факт) и [Remark](замечание)) обозначают одно и то же для Coq.

    Во-вторых, мы добавили квантор [forall n:nat](для всех n, где n --
    натуральное число), так что наша теорема относится ко _всем_
    натуральным числам. Неформально говоря, когда доказываем теоремы
    такого рода, мы обычно начинаем со слов "Предположим, что [n] --
    некоторое число...". Формально, мы достигаем этого эффекта с 
    помощью команды [intros n], которая перемещает [n] из квантора в
    цели в _контекст_ -- список текущих предположений.

    Ключевые слова [intros], [simpl] и [reflexivity] -- примеры 
    _тактик_. Тактика -- это команда, используемая между командами
    [Proof](доказательство) и [Qed](что и требовалось доказать) для
    того, чтобы направлять Coq для проверки сделанного нами
    утверждения. В следующих секциях этой главы мы увидим еще несколько
    тактик, и еще больше -- в следующих главах. *)

(** Другие подобные теоремы могут быть доказаны похожим образом. *)

Theorem plus_1_l : forall n:nat, 1 + n = S n.
Proof.
  intros n. reflexivity.  Qed.

Theorem mult_0_l : forall n:nat, 0 * n = 0.
Proof.
  intros n. reflexivity.  Qed.

(** Суффикс [_l] в названиях теорем означает "слева", например, 
    [plus_1_l] читается как "прибавить 1 слева" *)

(** Эти доказательства стоит пройти шаг за шагом в Coq, и пронаблюдать,
    как меняются цель и контекст. Также вы можете добавить [simpl]
    перед [reflexivity], чтобы увидеть, какие упрощения выполняются
    перед тем, как понять, что выражения по обе стороны равны. *)

(* ################################################################# *)
(** * Доказательство переписыванием *)

(** Следующая теорема немного более интересна, чем те, что мы уже
    видели: *)

Theorem plus_id_example : forall n m:nat,
  n = m ->
  n + n = m + m.

(** Вместо того, чтобы говорить обо всех числах [n] и [m], она
    описывает более специализированное свойство, которое верно, когда
    [n = m]. Символ стрелки читается как "означает, что" или "из того,
    что левая часть верна, следует, что правая часть верна".

    Как и прежде,  для рассуждений нам потребуется считать, что мы
    получили два числа [n] и [m]. Также мы должны принять гипотезу, что
    [n = m]. Тактика [intros] служит чтобы переместить все эти элементы
    из цели в предположения в текущем контексте.

    Так как [n] и [m] - произвольные числа, мы не можем воспользоваться
    вычислением для доказательства теоремы. Вместо этого мы докажем ее,
    заметив, что раз мы предположили [n = m], то мы можем заменить
    [n] на [m] в цели и получить равенство с одинаковыми выражениями
    по обе стороны. Тактика, которая говорит Coq выполнить эту 
    подстановку, называется [rewrite (переписать)]. *)

Proof.
  (* переместить n и m в контекст: *)
  intros n m.
  (* переместить гипотезу о равенстве n и m в контекст: *)
  intros H.
  (* переписать цель, используя гипотезу: *)
  rewrite -> H.
  reflexivity.  Qed.

(** Первая строка доказательства перемещает переменные [n] и [m],
    назрдящиеся под квантором всеобщности, в контекст. Вторая 
    перемещает гипотезу [n = n] в контекст и дает ей имя [H]/
    Третья строка говорит Coq, что требуется переписать текущую цель
    ([n + n = m + m]), заменив левую часть равенства в гипотезе [H]
    ее правой частью.

    (Символ стрелки в тактике [rewrite] не имеет ничего общего со
    следованием: он сообщает Coq, что нужно переписать слева направо.
    Чтобы переписать справа налево, вы можете использовать [rewrite <-].
    Попробуйте сделать это изменение в доказательстве выше и 
    пронаблюдать, к каким изменениям это приведет.) *)

(** **** Упражнение: 1 звезда (plus_id_exercise)  *)
(** Удалите "[Admitted.]" и заполните доказательство. *)

Theorem plus_id_exercise : forall n m o : nat,
  n = m -> m = o -> n + m = m + o.
Proof.
  (* ЗАПОЛНИТЕ *) Admitted.
(** [] *)

(** Команда [Admitted] сообщеает Coq, что мы хотим пропустить 
    доказательство и просто принять теорему как данность. Это может
    быть полезным для разработки более длинных доказательств, так как
    мы можем формулировать вспомогательные леммы, которые, по нашему
    мнению, будут полезны для доказательства, использовать [Admitted],
    чтобы пока что принять их на веру, и продолжить работу над основным
    доказательством. Потом мы можем вернуться и заполнить пропущенные
    доказательства. Однако, будьте остороны: каждый раз, когда вы
    используете команду [Admitted], вы оставляете возможность для
    абсурдного высказывания проникнуть в строгий, формально 
    верифицированный мир Coq! *)
  
(** Мы также можем использовать тактику [rewrite] вместе с теоремой,
    доказанной прежде, а не только с гипотезой из контекста. Если
    формулировка теоремы содержит обобщенные переменные, как в примере
    ниже, то Coq попытается вывести их, сравнивая с текущей целью. *)

Theorem mult_0_plus : forall n m : nat,
  (0 + n) * m = n * m.
Proof.
  intros n m.
  rewrite -> plus_O_n.
  reflexivity.  Qed.

(** **** Упражнение: 2 звезды (mult_S_1)  *)
Theorem mult_S_1 : forall n m : nat,
  m = S n ->
  m * (1 + n) = m * m.
Proof.
  (* ЗАПОЛНИТЕ *) Admitted.

  (* (Обратите внимание, что это доказательство можно провести без
     использования [rewrite], однако, пожалуйста, в целях практики,
     воспользуйтесь [rewrite].) *)
(** [] *)

(* ################################################################# *)
(** * Доказательство анализом случаев *)

(** Разумеется, не все можно доказать вычислениями и переписываниями:
    в общем случае, неизвестные значения из предположений
    (произвольные числа, логические значения, списки и т.д.) могут
    блокировать вычисленияю Например, если мы попробуем доказать 
    следующий факт, используя тактику [simpl], мы потерпим неудачу.
    (Следом мы используем команду [Abort], чтобы пока что прекратить 
    попытки доказательства). *)

Theorem plus_1_neq_0_firsttry : forall n : nat,
  beq_nat (n + 1) 0 = false.
Proof.
  intros n.
  simpl.  (* ничего не делает! *)
Abort.

(** Это происходит потому, что [beq_nat] и [plus] сперва производят
    сопоставление с образцом своего первого аргумента. Но здесь первый
    аргумент для [+] -- это неизвестное число [n], а аргумент для 
    [beq_nat] -- составное выражение [n + 1]. Они не могут быть
    упрощены.

    Чтобы продвинуться дальше, мы должны отдельно рассмотреть формы, 
    которые может принимать [n]. Если [n] -- это [O], тогда мы можем
    вычислить результат выражения [beq_nat (n + 1) 0] и проверить, что
    он, конечно же, равен [false]. А если [n = S n'] для некоторого
    [n'], несмотря на то, что мы не знаем точно, какое число возвращает
    [n + 1], мы можем вычислить, что оно начинается как минимум 
    с одного конструктора [S]. А этого, в свою очередь, достаточно,
    чтобы вычислить, что [beq_nat (n + 1) 0] возвращает [false].
    од

    Тактика, которая сообщает Coq, что мы хотим рассмотреть отдельно
    случаи [n = O] и [n = S n'], называется [destruct]. *)

Theorem plus_1_neq_0 : forall n : nat,
  beq_nat (n + 1) 0 = false.
Proof.
  intros n. destruct n as [| n'].
  - reflexivity.
  - reflexivity.   Qed.

(** Тактика [destruct] порождает _две_ подцели, которые мы затем должны
    доказать отдельно, чтобы Coq принял нашу туорему. Примечание
    "[as [| n']]" назывется _образцом введения_. Он говорит Coq, какие
    имена мы хотим дать переменным в каждой подцели. В общем случае,
    в квадратных скобках размещаются _списки списков_ имен, разделенных
    чертой [|]. В данном случае первый список пуст, поскольку 
    конструктор [O] не принимает аргументов. Второй список содержит
    одно имя -- [n'], потому что [S] - унарный конструктор (имеет один
    аргумент).

    Знаки [-] во второй и третьей строке называются _маркерами_ и
    отмечают части доказательства, соответствующие каждой порожденной
    подцели. Сценарий доказательства, который следует за маркером --
    это полное доказательство подцели. В данном примере каждая подцель
    может быть легко доказана с применением единственной тактики
    [reflexivity], которая сама проводит необходимые упрощения.
    Например, во втором случае упрощает [beq_nat (S n' + 1) 0] до
    [false], для чего сначала переписывает [(S n' + 1)] в виде 
    [S (n' + 1)], затем раскрывает определение [beq_nat], и упрощает
    выражение [match]. 

    Отмечать подцели маркерами не обязательно: если маркеры 
    отсутствуют, то Coq просто попросит доказать все подцели по очереди.
    Однако использование маркеров является хорошей идеей. Во-первых,
    они делают структуру доказательства более явной и более читаемой.
    Во-вторых, маркеры инструктируют Coq удостовериться, что подцель
    достигнута, прежде чем переходить к следующей. Это позволяет 
    избежать смешения доказательств для разных подцелей. Подобные
    проблемы особенно актальны в больших разработках, где "хрупкие",
    плохо организованные доказательства могут привести к долгой 
    отладке.
    
    В Coq нет каких-то жестких правил оформления доказательств, 
    в частности о том, где следует разбивать строки и как расставлять
    отступы в секциях. Несмотря на это, если те места, где порождаются
    несколько целей, отмечены маркерами в начале строки, то 
    доказательство будет читаемым почти независимо от решений, принятых
    в остальных аспектах форматирования.

    Здесь также стоит упомянуть о такой вещи, как длинна строк.
    Начинающие пользователи Coq впадают в крайности, как то записывают
    каждую тактику на отдельной строке, или записывают целые
    доказательства в одну строку. Хороший стиль -- что-то среднее.
    Одно из разумных соглашений - ограничиваться строками до 80
    символов.

    Тактику [destruct] можно применять к любому индуктивно заданному
    типу данных. Например, мы воспользуемся ей, чтобы доказать, что
    отрицание логического типа инволютивно, то есть отрицание является
    обратным самому себе. *)


Theorem negb_involutive : forall b : bool,
  negb (negb b) = b.
Proof.
  intros b. destruct b.
  - reflexivity.
  - reflexivity.  Qed.

(** Заметьте, что команда [destruct] здесь не имеет соответствующего
    блока [as], так как ни в одном из случаев не требуется вводить
    новые переменные (мы могли бы также написать [as [|]] или [as []]).
    В сущности, мы можем опустить блок [as] в _любом_ вызове тактики
    [destruct] и тогда Coq заполнит имена переменных автоматически.
    Это считается плохим стилем, так как Coq часто выбирает
    неочевидные имена, когда предоставлен сам себе.

    Тактику [destruct] иногда полезно применить внутри подцели (таким
    образом создав еще больше подцелей). В этом случае мы используем
    другие типы маркеров, чтобы отмечать цели на разных "уровнях".
    Например: *)

(* функция andb коммутативна *)
Theorem andb_commutative : forall b c, andb b c = andb c b.
Proof.
  intros b c. destruct b.
  - destruct c.
    + reflexivity.
    + reflexivity.
  - destruct c.
    + reflexivity.
    + reflexivity.
Qed.

(** Каждая пара вызовов тактики [reflexivity] соответствует подцелям,
    порожденным тактикой [destruct c] на предыдущей строке. *)

(** Кроме [-] и [+], мы можем использовать еще и звездочку [*] в 
    качестве третьего типа маркера. Также мы можем заключить 
    под-доказательства в фигурные скобки, что будет полезным в случае,
    когда в доказательстве встречается более трех уровней подцелей: *)

Theorem andb_commutative' : forall b c, andb b c = andb c b.
Proof.
  intros b c. destruct b.
  { destruct c.
    { reflexivity. }
    { reflexivity. } }
  { destruct c.
    { reflexivity. }
    { reflexivity. } }
Qed.

(** Так как фигурные скобки отмечают начало и конец доказательства,
    их можно использовать на нескольких уровнях, как показано в 
    примере. Более того, фигурные скобки позволяют переиспользовать
    один и тот же символ маркера на раных уровнях доказательства: *)

(* обмен в andb с тремя значениями *)
Theorem andb3_exchange :
  forall b c d, andb (andb b c) d = andb (andb b d) c.
Proof.
  intros b c d. destruct b.
  - destruct c.
    { destruct d.
      - reflexivity.
      - reflexivity. }
    { destruct d.
      - reflexivity.
      - reflexivity. }
  - destruct c.
    { destruct d.
      - reflexivity.
      - reflexivity. }
    { destruct d.
      - reflexivity.
      - reflexivity. }
Qed.

(** Прежде чем закончить эту главу, отметим еще одну удобную 
    возможность. Как вы могли заметить, многие доказательства выполняют
    анализ случаев на переменной сразу после ее введения:

       intros x y. destruct y as [|y].

    Этот шаблон настолько популярен, что Coq предоставляет для него
    сокращенный синтаксис: мы можем выполнять анализ переменной во
    время введения, используя _образец введения_ вместо имени 
    переменной. Например, вот более короткая версия доказательства
    теоремы [plus_1_neq_0]: *)

Theorem plus_1_neq_0' : forall n : nat,
  beq_nat (n + 1) 0 = false.
Proof.
  intros [|n].
  - reflexivity.
  - reflexivity.  Qed.

(** Если нет аргументов, которым нужно дать имя, то мы можем 
    использовать образец [[]]. *)

Theorem andb_commutative'' :
  forall b c, andb b c = andb c b.
Proof.
  intros [] [].
  - reflexivity.
  - reflexivity.
  - reflexivity.
  - reflexivity.
Qed.

(** **** Упражнение: 2 stars (andb_true_elim2)  *)
(** Докажите следующее утверждение, отмечая случаи (и подслучаи) 
    маркерами, когда используете [destruct]. *)

Theorem andb_true_elim2 : forall b c : bool,
  andb b c = true -> c = true.
Proof.
  (* ЗАПОЛНИТЕ *) Admitted.
(** [] *)

(** **** Упражнение: 1 star (zero_nbeq_plus_1)  *)
Theorem zero_nbeq_plus_1 : forall n : nat,
  beq_nat 0 (n + 1) = false.
Proof.
  (* ЗАПОЛНИТЕ *) Admitted.
(** [] *)

(* ================================================================= *)
(** ** Подробнее о нотациях (опционально) *)

(** (Секции, отмеченные как опциональные в основном не требуются для
    понимания остальной части книги, за исключением, возможно, других
    опциональных секций. При первом прочтении стоит просмотреть эти
    секции, чтобы иметь представление о чем в них говориться.) 

    Вспомним определение инфиксной нотации для сложения и умножения: *)

Notation "x + y" := (plus x y)
                       (at level 50, left associativity)
                       : nat_scope.
                        (* на уровне 50, левоассоциативная,
                        : в контексте натуральных чисел *) 
Notation "x * y" := (mult x y)
                       (at level 40, left associativity)
                       : nat_scope.
                        (* на уровне 40, левоассоциативная,
                        : в контексте натуральных чисел *) 

(** Для каждой нотации в Coq мы можем задать _уровень приоритета_
    и _ассоциативность_. Уровень приоритета [n] записывается как
    [at level n]. Это нужно, чтобы помочь Coq в разборе составных 
    выражений. Ассоциативность помогает понять, как нужно воспринимать
    выражения, содержащие несколько вхождений одной и той же нотации.
    Например, параметры, заданные выше для [+] и [*], говорят, что
    выражение [1+2*3*4] следует понимать как [(1 + ((2*3)*4)]. Coq
    поддерживает уровни приоритета от 0 до 100, а также 
    левоассоциативные (_left associativity_), правоассоциативные
    (_right associativity_), и неассоциативные (_no associativity_).
    Мы рассмотрим больше примеров в дальнейшем, в частности, в главе
    [Списки (Lists)].

    Каждая нтоация связана с _контекстом_ или _областью действия_. 
    Coq пытается определить, в каком контексте используется нотация,
    то есть, когда он видит [S(O*O)], то понимает, что работа идет
    с контекстом натуральных чисел [nat_scope], а когда видит декартово
    произведение (кортеж) типов [bool * bool] (которое мы рассмотрим
    в следующих главах) -- с контектом типов [type_scope]. Время от
    времени необходимо помочь с помощью символа %, написав [(x*y)%nat],
    а иногда Coq будет сам выводить [%nat], чтобы обозначить, что
    работает в контексте натуральных чисел.

    Контексты нотаций также применимы к числам ([3], [4], [5], и т.д.),
    так что иногда вы можете увидеть [0%nat], что означает [O] 
    (натуральное число [0], которое мы использовали в этой главе),
    а иногда -- [0%Z], что означает нолль в целых числах (которые 
    являются отдельной частью стандартной библиотеки).

    Профессиональный совет: механизм нотаций Coq не является каким-то
    особенно мощным. Не стоит ждать от него многого! *)

(* ================================================================= *)
(** ** Команда Fixpoint и структурная рекурсия (опционально) *)

(** Повторим определение сложения: *)

Fixpoint plus' (n : nat) (m : nat) : nat :=
  match n with
  | O => m
  | S n' => S (plus' n' m)
  end.

(** Когда Coq проверяет это определение, он видит, что [plus']
    "убывает по первому аргументу". Это значит, что мы выполняет
    _структурную рекурсию_ по ргументу [n], то есть мы делаем 
    рекурсивные вызовы только с строго меньшими значениями [n].
    Из этого следует, что любой вызов [plus'] рано или поздно
    завершается. Coq требует, чтобы какой-нибудь аргумент каждого
    рекурсивного определения с использованием команды [Fixpoint]
    "убывал".

    Это требование - фундаментальная особенность дизайна Coq:
    в частности, оно гарантирует, что любая функция, которую можно
    определить в Coq, завершается на любых входных данных. Однако,
    поскольку механизм "анализа убывания" не слишком мощный, иногда
    приходится записывать функции несколько неестественным образом. *)

(** **** Упражнение: 2 звезды, опционально (decreasing)  *)
(** Чтобы получить более конкретное представление об этой особенности,
    найдите способ записать осмысленное определение, используя
    [Fixpoint] (простую функцию на числах, например), которое
    _завершается_ на всех входных данных, но не проходит проверку 
    в Coq из-за данного ограничения. *)

(* ЗАПОЛНИТЕ *)
(** [] *)

(* ################################################################# *)
(** * Больше упражнений *)

(** **** Упражнение: 2 звезды (boolean_functions)  *)
(** Воспользуйтесь тактиками, которые вы уже изучили, чтобы доказать
    следующую теорему о логических функциях. *)

Theorem identity_fn_applied_twice :
  forall (f : bool -> bool),
  (forall (x : bool), f x = x) ->
  forall (b : bool), f (f b) = b.
Proof.
  (* ЗАПОЛНИТЕ *) Admitted.

(** Теперь сформулируйте и докажите теорему [negation_fn_applied_twice],
    по аналогии с предыдущей, в которой вторая гипотеза говорит, что
    функция [f] имеет свойство [f x = negb x].*)

(* ЗАПОЛНИТЕ *)
(** [] *)

(** **** Упражнение: 3 звезды, опционально (andb_eq_orb)  *)
(** Докажите теорему. (Подсказка: в зависимости от подхода, это может
    оказаться непростым. Вероятно, вам потребуются [destruct] и
    [rewrite] вместе, но применять [destruct] ко всему подряд -
    не лучшая идея.) *)

Theorem andb_eq_orb :
  forall (b c : bool),
  (andb b c = orb b c) ->
  b = c.
Proof.
  (* ЗАПОЛНИТЕ *) Admitted.

(** [] *)

(** **** Упражнение: 3 звезды (binary)  *)
(** Обдумайте другое, более эффективное представление натуральных
    чисел, используещее двоичную систему счисления. Таким образом,
    вместо того, чтобы говорить, что каждое натуральное число -- это
    либо ноль, либо оно следует за другим натуральным числом, мы 
    говорим, что каждое двоичное число это:

      - ноль
      - удвоенное двоичное число
      - на единицу больше чем удвоенное двоичное число

    (a) Во-первых, запишите индуктивное определение типа [bin],
        соответствующее этому описанию двоичных чисел.

        (Подсказка: вспомните, что определение натуральных чисел [nat],
        данное выше

          Inductive nat : Type := | O : nat | S : nat -> nat.

        ничего не говорит о том, что [O] и [S] "означают". Все, что оно
        говорит -- что "[O] принадлежит множеству [nat], и если [n]
        принадлежит множеству [nat], то [S n] тоже ему принадлежит".
        Наша интерпретация [O] как нуля и [S] как следующего числа
        исходит из того, как мы пользуемся значениями типа [nat],
        записывая функции, доказывая теоремы, и так далее. Ваше
        опрделение [bin] должно быть таким же простым. Математический
        смысл будет вложен в него функциями, которые вы напишите 
        далее.)

        Предостережение: если вы используете [O] или [S] в своем 
        определении, это запутает скрипт для автоматической оценки
        (BasicsTest.v). Пожалуйста, выберите другие имена.

    (b) Далее, напишите функцию инкремента двоичного числа [incr],
        и функцию [bin_to_nat] для преобразования двоичного числа
        в унарное представление [nat].

    (c) Напишите пять модульных тестов [test_bin_incr1], 
        [test_bin_incr2] и т.д. для функций инкремента и преобразования.
        "Модульный тест" в Coq -- это особый пример (Example), который
        может быть проверен при помощи единственной команды 
        [reflexivity]. Заметьте, что увеличить число на один и затем
        преобразовать его в унарное представление -- это то же самое,
        что и сначала преобразовать, а затем увеличить. *)

(* ЗАПОЛНИТЕ *)
(** [] *)

(** $Date: 2018-01-10 21:47:50 -0500 (Wed, 10 Jan 2018) $ *)

